第1章 对象导言/11
1.1 抽象的过程/11
1.2 对象有一个接口/12
1.3 实现的隐藏/14
1.4 实现的重用/15
1.5 继承：重用接口/15
1.5.1 is-a 关系和is-like-a 关系/18
1.6 具有多态性的可互换对象/18
1.7 创建和销毁对象/21
1.8 异常处理：应对错误/22
1.9 分析和设计/22
1.9.1 第0阶段：制定计划/24
1.9.2 第1阶段：我们在做什么/24
1.9.3 第2阶段：我们将如何建立对象/26
1.9.4 第3阶段：创建核心/28
1.9.5 第4阶段：迭代用例/29
1.9.6 第5阶段：进化/29
1.9.7 计划的回报/30
1.10 极限编程/30
1.10.1 先写测试/31
1.10.2 结对编程/32
1.11 为什么c++会成功/32
1.11.1 一个较好的c/32
1.11.2 延续式的学习过程/33
1.11.3 效率/33
1.11.4 系统更容易表达和理解/33
1.11.5 尽量使用库/33
1.11.6 利用模板的源代码重用/34
1.11.7 错误处理/34
1.11.8 大型程序设计/34
1.12 为向oop转变而采取的策略/34
1.12.1 指导方针/35
1.12.2 管理的障碍/35
1.13 小结/37
第2章 对象的创建与使用/38
2.1 语言的翻译过程/38
2.1.1 解释器/38
2.1.2 编译器/39
2.1.3 编译过程/39
2.2 分段编译工具/40
2.2.1 声明与定义/40
2.2.2 连接/44
2.2.3 使用库文件/44
2.3 编写第一个c++程序/45
2.3.1 使用iostream类/45
2.3.2 名字空间/46
2.3.3 程序的基本结构/47
2.3.4 “hello, world!”/47
2.3.5 运行编译器/48
2.4 关于输入输出流/48
2.4.1 字符数组的拼接/49
2.4.2 读取输入数据/49
2.4.3 调用其他程序/50
2.5 字符串简介/50
2.6 文件的读写/51
2.7 vector简介/52
2.8 小结/55
2.9 练习/56
第3章 c++中的c/57
3.1 创建函数/57
3.1.1 函数的返回值/58
3.1.2 使用c的函数库/59
3.1.3 通过库管理器创建自己的库/59
3.2 执行控制语句/60
3.2.1 真和假/60
3.2.2 if-else语句/60
3.2.3 while语句/61
3.2.4 do-while语句/61
3.2.5 for语句/62
3.2.6 关键字break 和 continue/63
3.2.7 switch语句/64
3.2.8 使用和滥用goto/65
3.2.9 递归/65
3.3 运算符简介/66
3.3.1 优先级/66
3.3.2 自增和自减/67
3.4 数据类型简介/67
3.4.1 基本内建类型/67
3.4.2 bool类型与true和false/68
3.4.3 说明符/69
3.4.4 指针简介/70
3.4.5 修改外部对象/72
3.4.6 c++引用简介/74
3.4.7 用指针和引用作为修饰符/75
3.5 作用域/76
3.5.1 实时定义变量/77
3.6 指定存储空间分配/78
3.6.1 全局变量/78
3.6.2 局部变量/79
3.6.3 静态变量/80
3.6.4 外部变量/81
3.6.5 常量/82
3.6.6 volatile变量/83
3.7 运算符及其使用/83
3.7.1 赋值/83
3.7.2 数学运算符/83
3.7.3 关系运算符/85
3.7.4 逻辑运算符/85
3.7.5 位运算符/85
3.7.6 移位运算符/86
3.7.7 一元运算符/88
3.7.8 三元运算符/88
3.7.9 逗号运算符/89
3.7.10 使用运算符时的常见问题/89
3.7.11 转换运算符/90
3.7.12 c++的显式转换/90
3.7.13 sizeof—独立运算符/93
3.7.14 asm 关键字/94
3.7.15 显式运算符/94
3.8 创建复合类型/94
3.8.1 用typedef命名别名/95
3.8.2 用struct把变量结合在一起/95
3.8.3 用enum提高程度清晰度/97
3.8.4 用union节省内存/98
3.8.5 数组/99
3.9 调试技巧/106
3.9.1 调试标记/106
3.9.2 把变量和表达式转换成字符串/108
3.9.3 c语言assert( )宏/108
3.10 函数地址/109
3.10.1 定义函数指针/109
3.10.2 复杂的声明和定义/109
3.10.3 使用函数指针/110
3.10.4 指向函数的指针数组/111
3.11 make：管理分段编译/111
3.11.1 make的行为/112
3.11.2 本书中的makefile/114
3.11.3 makefile的一个例子/114
3.12 小结/116
3.13 练习/116
第4章 数据抽象/119
4.1 一个袖珍c库/119
4.1.1 动态存储分配/122
4.1.2 有害的猜测/124
4.2 哪儿出问题/125
4.3 基本对象/126
4.4 什么是对象/130
4.5 抽象数据类型/131
4.6 对象细节/131
4.7 头文件形式/132
4.7.1 头文件的重要性/132
4.7.2 多次声明问题/133
4.7.3 预处理器指示#define、#ifdef和#endif/134
4.7.4 头文件的标准/134
4.7.5 头文件中的名字空间/135
4.7.6 在项目中使用头文件/135
4.8 嵌套结构/136
4.8.1 全局作用域解析/138
4.9 小结/139
4.10 练习/139
第5章 隐藏实现/142
5.1 设置限制/142
5.2 c++的访问控制/142
5.2.1 protected说明符/144
5.3 友元/144
5.3.1 嵌套友元/146
5.3.2 它是纯面向对象的吗/148
5.4 对象布局/148
5.5 类/149
5.5.1 用访问控制来修改stash/151
5.5.2 用访问控制来修改stack/151
5.6 句柄类/152
5.6.1 隐藏实现/152
5.6.2 减少重复编译/152
5.7 小结/154
5.8 练习/154
第6章 初始化与清除/156
6.1 用构造函数确保初始化/156
6.2 用析构函数确保清除/157
6.3 清除定义块/159
6.3.1 for循环/160
6.3.2 内存分配/161
6.4 带有构造函数和析构函数的stash/162
6.5 带有构造函数和析构函数的stack/164
6.6 聚合初始化/166
6.7 默认构造函数/168
6.8 小结/169
6.9 练习/169
第7章 函数重载与默认参数/171
7.1 名字修饰/172
7.1.1 用返回值重载/172
7.1.2 类型安全连接/172
7.2 重载的例子/173
7.3 联合/176
7.4 默认参数/178
7.4.1 占位符参数/179
7.5 选择重载还是默认参数/180
7.6 小结/183
7.7 练习/183
第8章 常量/185
8.1 值替代/185
8.1.1 头文件里的const/186
8.1.2 const的安全性/186
8.1.3 聚合/187
8.1.4 与c语言的区别/187
8.2 指针/188
8.2.1 指向const的指针/189
8.2.2 const指针/189
8.2.3 赋值和类型检查/190
8.3 函数参数和返回值/191
8.3.1 传递const值/191
8.3.2 返回const值/191
8.3.3 传递和返回地址/193
8.4 类/195
8.4.1 类里的const/196
8.4.2 编译期间类里的常量/198
8.4.3 const对象和成员函数/200
8.5 volatile/204
8.6 小结/205
8.7 练习/205
第9章 内联函数/207
9.1 预处理器的缺陷/207
9.1.1 宏和访问/209
9.2 内联函数/210
9.2.1 类内部的内联函数/210
9.2.2 访问函数/211
9.3 带内联函数的stash和stack/215
9.4 内联函数和编译器/218
9.4.1 限制/219
9.4.2 向前引用/219
9.4.3 在构造函数和析构函数里隐藏行为/220
9.5 减少混乱/220
9.6 预处理器的更多特征/221
9.6.1 标志粘贴/222
9.7 改进的错误检查/222
9.8 小结/225
9.9 练习/225
第10章 名字控制/227
10.1 来自c语言中的静态元素/227
10.1.1 函数内部的静态变量/227
10.1.2 控制连接/230
10.1.3 其他存储类型说明符/232
10.2 名字空间/232
10.2.1 创建一个名字空间/232
10.2.2 使用名字空间/234
10.2.3 名字空间的使用/237
10.3 c++中的静态成员/238
10.3.1 定义静态数据成员的存储/238
10.3.2 嵌套类和局部类/241
10.3.3 静态成员函数/242
10.4 静态初始化的相依性/244
10.4.1 怎么办/245
10.5 替代连接说明/250
10.6 小结/250
10.7 练习/251
第11章 引用和拷贝构造函数/254
11.1 c++中的指针/254
11.2 c++中的引用/254
11.2.1 函数中的引用/255
11.2.2 参数传递准则/257
11.3 拷贝构造函数/257
11.3.1 按值传递和返回/257
11.3.2 拷贝构造函数/261
11.3.3 默认拷贝构造函数/265
11.3.4 替代拷贝构造函数的方法/266
11.4 指向成员的指针/267
11.4.1 函数/269
11.5 小结/271
11.6 练习/271
第12章 运算符重载/274
12.1 两个极端/274
12.2 语法/274
12.3 可重载的运算符/275
12.3.1 一元运算符/276
12.3.2 二元运算符/279
12.3.3 参数和返回值/288
12.3.4 不常用的运算符/290
12.3.5 不能重载的运算符/295
12.4 非成员运算符/296
12.4.1 基本方针/297
12.5 重载赋值符/297
12.5.1 operator=的行为/298
12.6 自动类型转换/306
12.6.1 构造函数转换/306
12.6.2 运算符转换/307
12.6.3 类型转换例子/309
12.6.4 自动类型转换的缺陷/310
12.7 小结/312
12.8 练习/312
第13章 动态对象创建/315
13.1 对象创建/315
13.1.1 c从堆中获取存储单元的方法/316
13.1.2 operator new/317
13.1.3 operator delete/317
13.1.4 一个简单的例子/318
13.1.5 内存管理的开销/318
13.2 重新设计前面的例子/319
13.2.1 使用delete void*可能会出错/319
13.2.2 对指针的清除责任/320
13.2.3 指针的stash/320
13.3 用于数组的new和delete/324
13.3.1 使指针更像数组/325
13.4 耗尽内存/325
13.5 重载new和delete/326
13.5.1 重载全局new和delete/327
13.5.2 对于一个类重载new和delete/328
13.5.3 为数组重载new和delete/330
13.5.4 构造函数调用/332
13.5.5 定位new和delete/333
13.6 小结/334
13.7 练习/334
第14章 继承和组合/336
14.1 组合语法/336
14.2 继承语法/337
14.3 构造函数的初始化表达式表/339
14.3.1 成员对象初始化/339
14.3.2 在初始化表达式表中的内建类型/339
14.4 组合和继承的联合/340
14.4.1 构造函数和析构函数调用的次序/341
14.5 名字隐藏/343
14.6 非自动继承的函数/346
14.6.1 继承和静态成员函数/349
14.7 组合与继承的选择/349
14.7.1 子类型设置/350
14.7.2 私有继承/352
14.8 protected/353
14.8.1 protected继承/353
14.9 运算符的重载与继承/353
14.10 多重继承/355
14.11 渐增式开发/355
14.12 向上类型转换/356
14.12.1 为什么要“向上类型转换”/357
14.12.2 向上类型转换和拷贝构造函数/357
14.12.3 组合与继承（再论）/359
14.12.4 指针和引用的向上类型转换/360
14.12.5 危机/360
14.13 小结/361
14.14 练习/361
第15章 多态性和虚函数/364
15.1 c++程序员的演变/364
15.2 向上类型转换/365
15.3 问题/366
15.3.1 函数调用捆绑/366
15.4 虚函数/366
15.4.1 扩展性/367
15.5 c++如何实现晚捆绑/369
15.5.1 存放类型信息/370
15.5.2 虚函数功能图示/371
15.5.3 撩开面纱/372
15.5.4 安装vpointer/373
15.5.5 对象是不同的/373
15.6 为什么需要虚函数/374
15.7 抽象基类和纯虚函数/375
15.7.1 纯虚定义/378
15.8 继承和vtable/378
15.8.1 对象切片/380
15.9 重载和重新定义/382
15.9.1 变量返回类型/383
15.10 虚函数和构造函数/385
15.10.1 构造函数调用次序/385
15.10.2 虚函数在构造函数中的行为/386
15.11 析构函数和虚拟析构函数/386
15.11.1 纯虚析构函数/388
15.11.2 析构函数中的虚机制/389
15.11.3 创建基于对象的继承/390
15.12 运算符重载/392
15.13 向下类型转换/394
15.14 小结/396
15.15 练习/397
第16章 模板介绍/400
16.1 容器/400
16.1.1 容器的需求/401
16.2 模板综述/402
16.2.1 模板方法/403
16.3 模板语法/404
16.3.1 非内联函数定义/405
16.3.2 作为模板的intstack/406
16.3.3 模板中的常量/408
16.4 作为模板的stash和stack/409
16.4.1 模板化的指针stash/411
16.5 打开和关闭所有权/415
16.6 以值存放对象/417
16.7 迭代器简介/418
16.7.1 带有迭代器的栈/425
16.7.2 带有迭代器的pstash/427
16.8 为什么使用迭代器/432
16.8.1 函数模板/434
16.9 小结/435
16.10 练习/435
附录a 编码风格/438
附录b 编程准则/444
附录c 推荐读物/451