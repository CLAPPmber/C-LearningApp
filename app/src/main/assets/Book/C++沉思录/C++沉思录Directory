序幕/1
0.1第一次尝试/1
0.1.1改进/2
0.1.2另一种改进/3
0.2不用类来实现/4
0.3为什么用C++更简单/5
0.4一个更大的例子/6
0.5结论/6
第一篇动机/11
第1章 为什么我用C++/11
1.1  问题/11
1.2  历史背景/12
1.3　自动软件发布/12
1.3.1　可靠性与通用性/13
1.3.2　为什么用C/14
1.3.3　应付快速增长/15
1.4　进入C++/15
1.5　重复利用的软件/20
1.6　后记/21
第2章　为什么用C++工作/23
2.1　小项目的成功/23
2.1.1　开销/24
2.1.2　质疑软件工厂/24
2.2　抽象/25
2.2.1　有些抽象不是语言的一部分/26
2.2.2　抽象和规范/26
2.2.3　抽象和内存管理/27
2.3　机器应该为人服务/28
第3章　生活在现实世界中/29
第二篇　类和继承/37
第4章　类设计者的核查表/37
第5章　代理类/47
5.1　问题/47
5.2　经典解决方案/48
5.3　虚复制函数/49
5.4　定义代理类/50
5.5　小结/53
第6章　句柄：第一部分/55
6.1　问题/55
6.2　一个简单的类/56
6.3　绑定到句柄/58
6.4　获取对象/58
6.5　简单的实现/59
6.6　引用计数型句柄/60
6.7　写时复制/62
6.8　讨论/63
第7章　句柄：第二部分/67
7.1　回顾/68
7.2　分离引用计数/69
7.3　对引用计数的抽象/70
7.4　存取函数和写时复制/73
7.5　讨论/73
第8章　一个面向对象程序范例/75
8.1　问题描述/75
8.2　面向对象的解决方案/76
8.3　句柄类/79
8.4　扩展1：新操作/82
8.5　扩展2：增加新的节点类型/85
8.6　反思/86
第9章　一个课堂练习的分析(上)/89
9.1　问题描述/89
9.2　接口设计/91
9.3　补遗/93
9.4　测试接口/94
9.5　策略/95
9.6　方案/96
9.7　图像的组合/99
9.8　结论/102
第10章　一个课堂练习的分析(下)/103
10.1　策略/103
10.1.1　方案/104
10.1.2　内存分配/105
10.1.3　结构构造/107
10.1.4　显示图像/110
10.2　体验设计的灵活性/116
10.3　结论/119
第11章　什么时候不应当使用虚函数/121
11.1　适用的情况/121
11.2　不适用的情况/122
11.2.1　效率/122
11.2.2　你想要什么样的行为/125
11.2.3　不是所有的类都是通用的/127
11.3　析构函数很特殊/127
11.4　小结/129
第三篇　模板/131
第12章　设计容器类/133
12.1　包含什么/133
12.2　复制容器意味着什么/134
12.3　怎样获取容器的元素/137
12.4　怎样区分读和写/138
12.5　怎样处理容器的增长/139
12.6　容器支持哪些操作/141
12.7　怎样设想容器元素的类型/141
12.8　容器和继承/143
12.9　设计一个类似数组的类/144
第13章　访问容器中的元素/151
13.1　模拟指针/151
13.2　获取数据/153
13.3　遗留问题/155
13.4　指向const Array的Pointer/159
13.5　有用的增强操作/161
第14章　迭代器/167
14.1　完成Pointer类/167
14.2　什么是迭代器/170
14.3　删除元素/171
14.4　删除容器/172
14.5　其他设计考虑/173
14.6　讨论/174
第15章　序列/175
15.1　技术状况/175
15.2　基本的传统观点/176
15.3　增加一些额外操作/181
15.4　使用范例/184
15.5　再增加一些/188
15.6　请你思考/190
第16章　作为接口的模板/191
16.1　问题/191
16.2　第一个例子/192
16.3　分离迭代方式/192
16.4　遍历任意类型/195
16.5　增加其他类型/196
16.6　将存储技术抽象化/196
16.7　实证/199
16.8　小结/200
第17章　模板和泛型算法/203
17.1　一个特例/204
17.2　泛型化元素类型/205
17.3　推迟计数/205
17.4　地址独立性/207
17.5　查找非数组/208
17.6　讨论/210
第18章　泛型迭代器/213
18.1　一个不同的算法/213
18.2　需求的分类/215
18.3　输入迭代器/216
18.4　输出迭代器/216
18.5　前向迭代器/217
18.6　双向迭代器/218
18.7　随机存取迭代器/218
18.8　是继承吗/220
18.9　性能/220
18.10　小结/221
第19章　使用泛型迭代器/223
19.1　迭代器类型/224
19.2　虚拟序列/224
19.3　输出流迭代器/227
19.4　输入流迭代器/229
19.5　讨论/232
第20章　迭代器配接器/233
20.1　一个例子/233
20.2　方向不对称性/235
20.3　一致性和不对称性/236
20.4　自动反向/237
20.5　讨论/240
第21章　函数对象/241
21.1　一个例子/241
21.2　函数指针/244
21.3　函数对象/246
21.4　函数对象模板/248
21.5　隐藏中间类型/249
21.6　一种类型包罗万象/250
21.7　实现/251
21.8　讨论/253
第22章　函数配接器/255
22.1　为什么是函数对象/255
22.2　用于内建操作符的函数对象/256
22.3　绑定者(Binders)/257
22.4　更深入地探讨/258
22.5　接口继承/259
22.6　使用这些类/260
22.7　讨论/261
第四篇　库/263
第23章　日常使用的库/265
23.1　问题/265
23.2　理解问题：第1部分/267
23.3　实现：第1部分/267
23.4　理解问题：第2部分/270
23.5　实现：第2 部分/270
23.6　讨论/272
第24章　一个库接口设计实例/275
24.1　复杂问题/276
24.2　优化接口/277
24.3　温故知新/279
24.4　编写代码/280
24.5　结论/282
第25章　库设计就是语言设计/283
25.1　字符串/283
25.2　内存耗尽/284
25.3　复制/287
25.4　隐藏实现/290
25.5　缺省构造函数/292
25.6　其他操作/293
25.7　子字符串/295
25.8　结论/296
第26章　语言设计就是库设计/297
26.1　抽象数据类型/297
26.1.1　构造函数与析构函数/297
26.1.2　成员函数及可见度控制/299
26.2　库和抽象数据类型/299
26.2.1　类型安全的链接(linkage)/299
26.2.2　命名空间/300
26.3　内存分配/302
26.4　按成员赋值(memberwise assignment)和初始化/303
26.5　异常处理/305
26.6　小结/306
第五篇　技术/307
第27章　自己跟踪自己的类/309
27.1　设计一个跟踪类/309
27.2　创建死代码/312
27.3　生成对象的审计跟踪/313
27.4　验证容器行为/315
27.5　小结/320
第28章　在簇中分配对象/321
28.1　问题/321
28.2　设计方案/321
28.3　实现/324
28.4　加入继承/326
28.5　小结/327
第29章　应用器、操纵器和函数对象/329
29.1　问题/329
29.2　一种解决方案/332
29.3　另一种不同的解决方案/332
29.4　多个参数/334
29.5　一个例子/335
29.6　简化/337
29.7　思考/338
29.8　历史记录、参考资料和致谢/339
第30章　将应用程序库从输入输出中分离出来/341
30.1　问题/341
30.2　解决方案1：技巧加蛮力/342
30.3　解决方案2：抽象输出/343
30.4　解决方案3：技巧，但无蛮力/345
30.5　评论/348
第六篇　总结/349
第31章　通过复杂性获取简单性/351
31.1　世界是复杂的/351
31.2　复杂性变得隐蔽/352
31.3　计算机也是一样/353
31.4　计算机解决实际问题/354
31.5　类库和语言语义/355
31.6　很难使事情变得容易/357
31.7　抽象和接口/357
31.8　复杂度的守恒/358
第32章　说了Hello world后再做什么/361
32.1　找当地的专家/361
32.2　选一种工具包并适应它/362
32.3　C的某些部分是必需的/362
32.4　C的其他部分不是必需的/364
32.5　给自己设一些问题/366
32.6　结论/368
附录　Koenig和Moo夫妇访谈/371
索引/377